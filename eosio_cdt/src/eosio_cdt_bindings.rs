/* automatically generated by rust-bindgen */

pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST64_MAX: i32 = -1;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INTMAX_MIN: i64 = -9223372036854775808;
pub const INTMAX_MAX: u64 = 9223372036854775807;
pub const UINTMAX_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __bool_true_false_are_defined: u32 = 1;
pub const _BSD_SOURCE: u32 = 1;
pub const _XOPEN_SOURCE: u32 = 700;
pub const NULL: u32 = 0;
pub const WEOF: u32 = 4294967295;
pub type uint128_t = u128;
pub type int128_t = i128;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type wint_t = u32;
pub type va_list = __builtin_va_list;
pub type __isoc_va_list = __builtin_va_list;
pub type wctype_t = ::std::os::raw::c_ulong;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __mbstate_t {
    pub __opaque1: ::std::os::raw::c_uint,
    pub __opaque2: ::std::os::raw::c_uint,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        8usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        4usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__opaque1 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__opaque1)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__mbstate_t>())).__opaque2 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__opaque2)
        )
    );
}
pub type mbstate_t = __mbstate_t;
pub type regoff_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __locale_struct {
    _unused: [u8; 0],
}
pub type locale_t = *mut __locale_struct;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _IO_FILE {
    _unused: [u8; 0],
}
pub type FILE = _IO_FILE;
pub type off_t = i64;
pub type time_t = ::std::os::raw::c_long;
pub type suseconds_t = ::std::os::raw::c_long;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timeval {
    pub tv_sec: time_t,
    pub tv_usec: suseconds_t,
}
#[test]
fn bindgen_test_layout_timeval() {
    assert_eq!(
        ::std::mem::size_of::<timeval>(),
        16usize,
        concat!("Size of: ", stringify!(timeval))
    );
    assert_eq!(
        ::std::mem::align_of::<timeval>(),
        8usize,
        concat!("Alignment of ", stringify!(timeval))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timeval>())).tv_usec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timeval),
            "::",
            stringify!(tv_usec)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct timespec {
    pub tv_sec: time_t,
    pub tv_nsec: ::std::os::raw::c_long,
}
#[test]
fn bindgen_test_layout_timespec() {
    assert_eq!(
        ::std::mem::size_of::<timespec>(),
        16usize,
        concat!("Size of: ", stringify!(timespec))
    );
    assert_eq!(
        ::std::mem::align_of::<timespec>(),
        8usize,
        concat!("Alignment of ", stringify!(timespec))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_sec as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_sec)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<timespec>())).tv_nsec as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(timespec),
            "::",
            stringify!(tv_nsec)
        )
    );
}
pub type float_t = f32;
pub type double_t = f64;
extern "C" {
    pub fn wcscpy(arg1: *mut u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsncpy(arg1: *mut u32, arg2: *const u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn wcscat(arg1: *mut u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsncat(arg1: *mut u32, arg2: *const u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn wcscmp(arg1: *const u32, arg2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncmp(arg1: *const u32, arg2: *const u32, arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll(arg1: *const u32, arg2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm(arg1: *mut u32, arg2: *const u32, arg3: usize) -> usize;
}
extern "C" {
    pub fn wcschr(arg1: *const u32, arg2: u32) -> *mut u32;
}
extern "C" {
    pub fn wcsrchr(arg1: *const u32, arg2: u32) -> *mut u32;
}
extern "C" {
    pub fn wcscspn(arg1: *const u32, arg2: *const u32) -> usize;
}
extern "C" {
    pub fn wcsspn(arg1: *const u32, arg2: *const u32) -> usize;
}
extern "C" {
    pub fn wcspbrk(arg1: *const u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcstok(arg1: *mut u32, arg2: *const u32, arg3: *mut *mut u32) -> *mut u32;
}
extern "C" {
    pub fn wcslen(arg1: *const u32) -> usize;
}
extern "C" {
    pub fn wcsstr(arg1: *const u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcswcs(arg1: *const u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wmemchr(arg1: *const u32, arg2: u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn wmemcmp(arg1: *const u32, arg2: *const u32, arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wmemcpy(arg1: *mut u32, arg2: *const u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn wmemmove(arg1: *mut u32, arg2: *const u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn wmemset(arg1: *mut u32, arg2: u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn btowc(arg1: ::std::os::raw::c_int) -> wint_t;
}
extern "C" {
    pub fn wctob(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbsinit(arg1: *const mbstate_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn mbrtowc(
        arg1: *mut u32,
        arg2: *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcrtomb(arg1: *mut ::std::os::raw::c_char, arg2: u32, arg3: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbrlen(arg1: *const ::std::os::raw::c_char, arg2: usize, arg3: *mut mbstate_t) -> usize;
}
extern "C" {
    pub fn mbsrtowcs(
        arg1: *mut u32,
        arg2: *mut *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsrtombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *const u32,
        arg3: usize,
        arg4: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcstof(arg1: *const u32, arg2: *mut *mut u32) -> f32;
}
extern "C" {
    pub fn wcstod(arg1: *const u32, arg2: *mut *mut u32) -> f64;
}
extern "C" {
    pub fn wcstold(arg1: *const u32, arg2: *mut *mut u32) -> u128;
}
extern "C" {
    pub fn wcstol(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_long;
}
extern "C" {
    pub fn wcstoul(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulong;
}
extern "C" {
    pub fn wcstoll(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_longlong;
}
extern "C" {
    pub fn wcstoull(
        arg1: *const u32,
        arg2: *mut *mut u32,
        arg3: ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_ulonglong;
}
extern "C" {
    pub fn fwide(arg1: *mut FILE, arg2: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wprintf(arg1: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwprintf(arg1: *mut FILE, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swprintf(arg1: *mut u32, arg2: usize, arg3: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwprintf(arg1: *const u32, arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwprintf(
        arg1: *mut FILE,
        arg2: *const u32,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswprintf(
        arg1: *mut u32,
        arg2: usize,
        arg3: *const u32,
        arg4: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wscanf(arg1: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fwscanf(arg1: *mut FILE, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn swscanf(arg1: *const u32, arg2: *const u32, ...) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vwscanf(arg1: *const u32, arg2: *mut __va_list_tag) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vfwscanf(
        arg1: *mut FILE,
        arg2: *const u32,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn vswscanf(
        arg1: *const u32,
        arg2: *const u32,
        arg3: *mut __va_list_tag,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn fgetwc(arg1: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwc(arg1: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn getwchar() -> wint_t;
}
extern "C" {
    pub fn fputwc(arg1: u32, arg2: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwc(arg1: u32, arg2: *mut FILE) -> wint_t;
}
extern "C" {
    pub fn putwchar(arg1: u32) -> wint_t;
}
extern "C" {
    pub fn fgetws(arg1: *mut u32, arg2: ::std::os::raw::c_int, arg3: *mut FILE) -> *mut u32;
}
extern "C" {
    pub fn fputws(arg1: *const u32, arg2: *mut FILE) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn ungetwc(arg1: wint_t, arg2: *mut FILE) -> wint_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct tm {
    _unused: [u8; 0],
}
extern "C" {
    pub fn wcsftime(arg1: *mut u32, arg2: usize, arg3: *const u32, arg4: *const tm) -> usize;
}
extern "C" {
    pub fn wcsftime_l(
        arg1: *mut u32,
        arg2: usize,
        arg3: *const u32,
        arg4: *const tm,
        arg5: locale_t,
    ) -> usize;
}
extern "C" {
    pub fn open_wmemstream(arg1: *mut *mut u32, arg2: *mut usize) -> *mut FILE;
}
extern "C" {
    pub fn mbsnrtowcs(
        arg1: *mut u32,
        arg2: *mut *const ::std::os::raw::c_char,
        arg3: usize,
        arg4: usize,
        arg5: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsnrtombs(
        arg1: *mut ::std::os::raw::c_char,
        arg2: *mut *const u32,
        arg3: usize,
        arg4: usize,
        arg5: *mut mbstate_t,
    ) -> usize;
}
extern "C" {
    pub fn wcsdup(arg1: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcsnlen(arg1: *const u32, arg2: usize) -> usize;
}
extern "C" {
    pub fn wcpcpy(arg1: *mut u32, arg2: *const u32) -> *mut u32;
}
extern "C" {
    pub fn wcpncpy(arg1: *mut u32, arg2: *const u32, arg3: usize) -> *mut u32;
}
extern "C" {
    pub fn wcscasecmp(arg1: *const u32, arg2: *const u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscasecmp_l(
        arg1: *const u32,
        arg2: *const u32,
        arg3: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp(arg1: *const u32, arg2: *const u32, arg3: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsncasecmp_l(
        arg1: *const u32,
        arg2: *const u32,
        arg3: usize,
        arg4: locale_t,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcscoll_l(arg1: *const u32, arg2: *const u32, arg3: locale_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcsxfrm_l(arg1: *mut u32, arg2: *const u32, arg3: usize, arg4: locale_t) -> usize;
}
extern "C" {
    pub fn wcwidth(arg1: u32) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn wcswidth(arg1: *const u32, arg2: usize) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalnum(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswalpha(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswblank(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswcntrl(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswdigit(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswgraph(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswlower(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswprint(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswpunct(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswspace(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswupper(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswxdigit(arg1: wint_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn iswctype(arg1: wint_t, arg2: wctype_t) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn towlower(arg1: wint_t) -> wint_t;
}
extern "C" {
    pub fn towupper(arg1: wint_t) -> wint_t;
}
extern "C" {
    pub fn wctype(arg1: *const ::std::os::raw::c_char) -> wctype_t;
}
pub type capi_name = u64;
#[doc = " EOSIO Public Key. K1 and R1 keys are 34 bytes.  Newer keys can be variable-sized"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct capi_public_key {
    pub data: [::std::os::raw::c_char; 34usize],
}
#[test]
fn bindgen_test_layout_capi_public_key() {
    assert_eq!(
        ::std::mem::size_of::<capi_public_key>(),
        34usize,
        concat!("Size of: ", stringify!(capi_public_key))
    );
    assert_eq!(
        ::std::mem::align_of::<capi_public_key>(),
        1usize,
        concat!("Alignment of ", stringify!(capi_public_key))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capi_public_key>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capi_public_key),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " EOSIO Signature. K1 and R1 signatures are 66 bytes. Newer signatures can be variable-sized"]
#[repr(C)]
#[derive(Copy, Clone)]
pub struct capi_signature {
    pub data: [u8; 66usize],
}
#[test]
fn bindgen_test_layout_capi_signature() {
    assert_eq!(
        ::std::mem::size_of::<capi_signature>(),
        66usize,
        concat!("Size of: ", stringify!(capi_signature))
    );
    assert_eq!(
        ::std::mem::align_of::<capi_signature>(),
        1usize,
        concat!("Alignment of ", stringify!(capi_signature))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capi_signature>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capi_signature),
            "::",
            stringify!(data)
        )
    );
}
#[doc = " 256-bit hash"]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct capi_checksum256 {
    pub hash: [u8; 32usize],
}
#[test]
fn bindgen_test_layout_capi_checksum256() {
    assert_eq!(
        ::std::mem::size_of::<capi_checksum256>(),
        32usize,
        concat!("Size of: ", stringify!(capi_checksum256))
    );
    assert_eq!(
        ::std::mem::align_of::<capi_checksum256>(),
        16usize,
        concat!("Alignment of ", stringify!(capi_checksum256))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capi_checksum256>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capi_checksum256),
            "::",
            stringify!(hash)
        )
    );
}
#[doc = " 160-bit hash"]
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct capi_checksum160 {
    pub hash: [u8; 20usize],
    pub __bindgen_padding_0: [u32; 3usize],
}
#[test]
fn bindgen_test_layout_capi_checksum160() {
    assert_eq!(
        ::std::mem::size_of::<capi_checksum160>(),
        32usize,
        concat!("Size of: ", stringify!(capi_checksum160))
    );
    assert_eq!(
        ::std::mem::align_of::<capi_checksum160>(),
        16usize,
        concat!("Alignment of ", stringify!(capi_checksum160))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capi_checksum160>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capi_checksum160),
            "::",
            stringify!(hash)
        )
    );
}
#[doc = " 512-bit hash"]
#[repr(C)]
#[repr(align(16))]
#[derive(Copy, Clone)]
pub struct capi_checksum512 {
    pub hash: [u8; 64usize],
}
#[test]
fn bindgen_test_layout_capi_checksum512() {
    assert_eq!(
        ::std::mem::size_of::<capi_checksum512>(),
        64usize,
        concat!("Size of: ", stringify!(capi_checksum512))
    );
    assert_eq!(
        ::std::mem::align_of::<capi_checksum512>(),
        16usize,
        concat!("Alignment of ", stringify!(capi_checksum512))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<capi_checksum512>())).hash as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(capi_checksum512),
            "::",
            stringify!(hash)
        )
    );
}
extern "C" {
    #[doc = "  Copy up to length bytes of current action data to the specified location"]
    #[doc = ""]
    #[doc = "  @brief Copy current action data to the specified location"]
    #[doc = "  @param msg - a pointer where up to length bytes of the current action data will be copied"]
    #[doc = "  @param len - len of the current action data to be copied, 0 to report required size"]
    #[doc = "  @return the number of bytes copied to msg, or number of bytes that can be copied if len==0 passed"]
    #[doc = "  @pre `msg` is a valid pointer to a range of memory at least `len` bytes long"]
    #[doc = "  @post `msg` is filled with packed action data"]
    pub fn read_action_data(msg: *mut ::std::os::raw::c_void, len: u32) -> u32;
}
extern "C" {
    #[doc = " Get the length of the current action's data field. This method is useful for dynamically sized actions"]
    #[doc = ""]
    #[doc = " @brief Get the length of current action's data field"]
    #[doc = " @return the length of the current action's data field"]
    pub fn action_data_size() -> u32;
}
extern "C" {
    #[doc = "  Add the specified account to set of accounts to be notified"]
    #[doc = ""]
    #[doc = "  @brief Add the specified account to set of accounts to be notified"]
    #[doc = "  @param name - name of the account to be verified"]
    pub fn require_recipient(name: capi_name);
}
extern "C" {
    #[doc = "  Verifies that name exists in the set of provided auths on a action. Throws if not found."]
    #[doc = ""]
    #[doc = "  @brief Verify specified account exists in the set of provided auths"]
    #[doc = "  @param name - name of the account to be verified"]
    pub fn require_auth(name: capi_name);
}
extern "C" {
    #[doc = "  Verifies that name has auth."]
    #[doc = ""]
    #[doc = "  @brief Verifies that name has auth."]
    #[doc = "  @param name - name of the account to be verified"]
    pub fn has_auth(name: capi_name) -> bool;
}
extern "C" {
    #[doc = "  Verifies that name exists in the set of provided auths on a action. Throws if not found."]
    #[doc = ""]
    #[doc = "  @brief Verify specified account exists in the set of provided auths"]
    #[doc = "  @param name - name of the account to be verified"]
    #[doc = "  @param permission - permission level to be verified"]
    pub fn require_auth2(name: capi_name, permission: capi_name);
}
extern "C" {
    #[doc = "  Verifies that @ref name is an existing account."]
    #[doc = ""]
    #[doc = "  @brief Verifies that @ref name is an existing account."]
    #[doc = "  @param name - name of the account to check"]
    pub fn is_account(name: capi_name) -> bool;
}
extern "C" {
    #[doc = "  Send an inline action in the context of this action's parent transaction"]
    #[doc = ""]
    #[doc = "  @param serialized_action - serialized action"]
    #[doc = "  @param size - size of serialized action in bytes"]
    #[doc = "  @pre `serialized_action` is a valid pointer to an array at least `size` bytes long"]
    pub fn send_inline(serialized_action: *mut ::std::os::raw::c_char, size: usize);
}
extern "C" {
    #[doc = " /function"]
    #[doc = "  Send an inline context free action in the context of this action's parent transaction"]
    #[doc = ""]
    #[doc = "  @param serialized_action - serialized action"]
    #[doc = "  @param size - size of serialized action in bytes"]
    #[doc = "  @pre `serialized_action` is a valid pointer to an array at least `size` bytes long"]
    pub fn send_context_free_inline(serialized_action: *mut ::std::os::raw::c_char, size: usize);
}
extern "C" {
    #[doc = "  Returns the time in microseconds from 1970 of the publication_time"]
    #[doc = "  @brief Get the publication time"]
    #[doc = "  @return the time in microseconds from 1970 of the publication_time"]
    pub fn publication_time() -> u64;
}
extern "C" {
    #[doc = "  Get the current receiver of the action"]
    #[doc = "  @brief Get the current receiver of the action"]
    #[doc = "  @return the account which specifies the current receiver of the action"]
    pub fn current_receiver() -> capi_name;
}
extern "C" {
    #[doc = "  Tests if the sha256 hash generated from data matches the provided checksum."]
    #[doc = ""]
    #[doc = "  @param data - Data you want to hash"]
    #[doc = "  @param length - Data length"]
    #[doc = "  @param hash - `capi_checksum256*` hash to compare to"]
    #[doc = ""]
    #[doc = "  @pre **assert256 hash** of `data` equals provided `hash` parameter."]
    #[doc = "  @post Executes next statement. If was not `true`, hard return."]
    #[doc = ""]
    #[doc = "  @note This method is optimized to a NO-OP when in fast evaluation mode."]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  checksum hash;"]
    #[doc = "  char data;"]
    #[doc = "  uint32_t length;"]
    #[doc = "  assert_sha256( data, length, hash )"]
    #[doc = "  //If the sha256 hash generated from data does not equal provided hash, anything below will never fire."]
    #[doc = "  eosio::print(\"sha256 hash generated from data equals provided hash\");"]
    #[doc = "  @endcode"]
    pub fn assert_sha256(
        data: *const ::std::os::raw::c_char,
        length: u32,
        hash: *const capi_checksum256,
    );
}
extern "C" {
    #[doc = "  Tests if the sha1 hash generated from data matches the provided checksum."]
    #[doc = ""]
    #[doc = "  @note This method is optimized to a NO-OP when in fast evaluation mode."]
    #[doc = "  @param data - Data you want to hash"]
    #[doc = "  @param length - Data length"]
    #[doc = "  @param hash - `capi_checksum160*` hash to compare to"]
    #[doc = ""]
    #[doc = "  @pre **sha1 hash** of `data` equals provided `hash` parameter."]
    #[doc = "  @post Executes next statement. If was not `true`, hard return."]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  checksum hash;"]
    #[doc = "  char data;"]
    #[doc = "  uint32_t length;"]
    #[doc = "  assert_sha1( data, length, hash )"]
    #[doc = "  //If the sha1 hash generated from data does not equal provided hash, anything below will never fire."]
    #[doc = "  eosio::print(\"sha1 hash generated from data equals provided hash\");"]
    #[doc = "  @endcode"]
    pub fn assert_sha1(
        data: *const ::std::os::raw::c_char,
        length: u32,
        hash: *const capi_checksum160,
    );
}
extern "C" {
    #[doc = "  Tests if the sha512 hash generated from data matches the provided checksum."]
    #[doc = ""]
    #[doc = "  @note This method is optimized to a NO-OP when in fast evaluation mode."]
    #[doc = "  @param data - Data you want to hash"]
    #[doc = "  @param length - Data length"]
    #[doc = "  @param hash - `capi_checksum512*` hash to compare to"]
    #[doc = ""]
    #[doc = "  @pre **assert512 hash** of `data` equals provided `hash` parameter."]
    #[doc = "  @post Executes next statement. If was not `true`, hard return."]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  checksum hash;"]
    #[doc = "  char data;"]
    #[doc = "  uint32_t length;"]
    #[doc = "  assert_sha512( data, length, hash )"]
    #[doc = "  //If the sha512 hash generated from data does not equal provided hash, anything below will never fire."]
    #[doc = "  eosio::print(\"sha512 hash generated from data equals provided hash\");"]
    #[doc = "  @endcode"]
    pub fn assert_sha512(
        data: *const ::std::os::raw::c_char,
        length: u32,
        hash: *const capi_checksum512,
    );
}
extern "C" {
    #[doc = "  Tests if the ripemod160 hash generated from data matches the provided checksum."]
    #[doc = ""]
    #[doc = "  @param data - Data you want to hash"]
    #[doc = "  @param length - Data length"]
    #[doc = "  @param hash - `capi_checksum160*` hash to compare to"]
    #[doc = ""]
    #[doc = "  @pre **assert160 hash** of `data` equals provided `hash` parameter."]
    #[doc = "  @post Executes next statement. If was not `true`, hard return."]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  checksum hash;"]
    #[doc = "  char data;"]
    #[doc = "  uint32_t length;"]
    #[doc = "  assert_ripemod160( data, length, hash )"]
    #[doc = "  //If the ripemod160 hash generated from data does not equal provided hash, anything below will never fire."]
    #[doc = "  eosio::print(\"ripemod160 hash generated from data equals provided hash\");"]
    #[doc = "  @endcode"]
    pub fn assert_ripemd160(
        data: *const ::std::os::raw::c_char,
        length: u32,
        hash: *const capi_checksum160,
    );
}
extern "C" {
    #[doc = "  Hashes `data` using `sha256` and stores result in memory pointed to by hash."]
    #[doc = ""]
    #[doc = "  @param data - Data you want to hash"]
    #[doc = "  @param length - Data length"]
    #[doc = "  @param hash - Hash pointer"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  checksum calc_hash;"]
    #[doc = "  sha256( data, length, &calc_hash );"]
    #[doc = "  eos_assert( calc_hash == hash, \"invalid hash\" );"]
    #[doc = "  @endcode"]
    pub fn sha256(data: *const ::std::os::raw::c_char, length: u32, hash: *mut capi_checksum256);
}
extern "C" {
    #[doc = "  Hashes `data` using `sha1` and stores result in memory pointed to by hash."]
    #[doc = ""]
    #[doc = "  @param data - Data you want to hash"]
    #[doc = "  @param length - Data length"]
    #[doc = "  @param hash - Hash pointer"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  checksum calc_hash;"]
    #[doc = "  sha1( data, length, &calc_hash );"]
    #[doc = "  eos_assert( calc_hash == hash, \"invalid hash\" );"]
    #[doc = "  @endcode"]
    pub fn sha1(data: *const ::std::os::raw::c_char, length: u32, hash: *mut capi_checksum160);
}
extern "C" {
    #[doc = "  Hashes `data` using `sha512` and stores result in memory pointed to by hash."]
    #[doc = ""]
    #[doc = "  @param data - Data you want to hash"]
    #[doc = "  @param length - Data length"]
    #[doc = "  @param hash - Hash pointer"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  checksum calc_hash;"]
    #[doc = "  sha512( data, length, &calc_hash );"]
    #[doc = "  eos_assert( calc_hash == hash, \"invalid hash\" );"]
    #[doc = "  @endcode"]
    pub fn sha512(data: *const ::std::os::raw::c_char, length: u32, hash: *mut capi_checksum512);
}
extern "C" {
    #[doc = "  Hashes `data` using `ripemod160` and stores result in memory pointed to by hash."]
    #[doc = ""]
    #[doc = "  @param data - Data you want to hash"]
    #[doc = "  @param length - Data length"]
    #[doc = "  @param hash - Hash pointer"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  checksum calc_hash;"]
    #[doc = "  ripemod160( data, length, &calc_hash );"]
    #[doc = "  eos_assert( calc_hash == hash, \"invalid hash\" );"]
    #[doc = "  @endcode"]
    pub fn ripemd160(data: *const ::std::os::raw::c_char, length: u32, hash: *mut capi_checksum160);
}
extern "C" {
    #[doc = "  Calculates the public key used for a given signature and hash used to create a message."]
    #[doc = ""]
    #[doc = "  @param digest - Hash used to create a message"]
    #[doc = "  @param sig - Signature"]
    #[doc = "  @param siglen - Signature length"]
    #[doc = "  @param pub - Public key"]
    #[doc = "  @param publen - Public key length"]
    #[doc = "   @return int - number of bytes written to pub"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  @endcode"]
    pub fn recover_key(
        digest: *const capi_checksum256,
        sig: *const ::std::os::raw::c_char,
        siglen: usize,
        pub_: *mut ::std::os::raw::c_char,
        publen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Tests a given public key with the generated key from digest and the signature."]
    #[doc = ""]
    #[doc = "  @param digest - What the key will be generated from"]
    #[doc = "  @param sig - Signature"]
    #[doc = "  @param siglen - Signature length"]
    #[doc = "  @param pub - Public key"]
    #[doc = "  @param publen - Public key length"]
    #[doc = ""]
    #[doc = "  @pre **assert recovery key** of `pub` equals the key generated from the `digest` parameter"]
    #[doc = "  @post Executes next statement. If was not `true`, hard return."]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  checksum digest;"]
    #[doc = "  char sig;"]
    #[doc = "  size_t siglen;"]
    #[doc = "  char pub;"]
    #[doc = "  size_t publen;"]
    #[doc = "  assert_recover_key( digest, sig, siglen, pub, publen )"]
    #[doc = "  // If the given public key does not match with the generated key from digest and the signature, anything below will never fire."]
    #[doc = "  eosio::print(\"pub key matches the pub key generated from digest\");"]
    #[doc = "  @endcode"]
    pub fn assert_recover_key(
        digest: *const capi_checksum256,
        sig: *const ::std::os::raw::c_char,
        siglen: usize,
        pub_: *const ::std::os::raw::c_char,
        publen: usize,
    );
}
extern "C" {
    #[doc = "  Checks if a transaction is authorized by a provided set of keys and permissions"]
    #[doc = ""]
    #[doc = "  @param trx_data - pointer to the start of the serialized transaction"]
    #[doc = "  @param trx_size - size (in bytes) of the serialized transaction"]
    #[doc = "  @param pubkeys_data - pointer to the start of the serialized vector of provided public keys"]
    #[doc = "  @param pubkeys_size  - size (in bytes) of serialized vector of provided public keys (can be 0 if no public keys are to be provided)"]
    #[doc = "  @param perms_data - pointer to the start of the serialized vector of provided permissions (empty permission name acts as wildcard)"]
    #[doc = "  @param perms_size - size (in bytes) of the serialized vector of provided permissions"]
    #[doc = ""]
    #[doc = "  @return 1 if the transaction is authorized, 0 otherwise"]
    pub fn check_transaction_authorization(
        trx_data: *const ::std::os::raw::c_char,
        trx_size: u32,
        pubkeys_data: *const ::std::os::raw::c_char,
        pubkeys_size: u32,
        perms_data: *const ::std::os::raw::c_char,
        perms_size: u32,
    ) -> i32;
}
extern "C" {
    #[doc = "  Checks if a permission is authorized by a provided delay and a provided set of keys and permissions"]
    #[doc = ""]
    #[doc = "  @param account - the account owner of the permission"]
    #[doc = "  @param permission - the name of the permission to check for authorization"]
    #[doc = "  @param pubkeys_data - pointer to the start of the serialized vector of provided public keys"]
    #[doc = "  @param pubkeys_size  - size (in bytes) of serialized vector of provided public keys (can be 0 if no public keys are to be provided)"]
    #[doc = "  @param perms_data - pointer to the start of the serialized vector of provided permissions (empty permission name acts as wildcard)"]
    #[doc = "  @param perms_size - size (in bytes) of the serialized vector of provided permissions"]
    #[doc = "  @param delay_us - the provided delay in microseconds (cannot exceed INT64_MAX)"]
    #[doc = ""]
    #[doc = "  @return 1 if the permission is authorized, 0 otherwise"]
    pub fn check_permission_authorization(
        account: capi_name,
        permission: capi_name,
        pubkeys_data: *const ::std::os::raw::c_char,
        pubkeys_size: u32,
        perms_data: *const ::std::os::raw::c_char,
        perms_size: u32,
        delay_us: u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Returns the last used time of a permission"]
    #[doc = ""]
    #[doc = "  @param account    - the account owner of the permission"]
    #[doc = "  @param permission - the name of the permission"]
    #[doc = ""]
    #[doc = "  @return the last used time (in microseconds since Unix epoch) of the permission"]
    pub fn get_permission_last_used(account: capi_name, permission: capi_name) -> i64;
}
extern "C" {
    #[doc = "  Returns the creation time of an account"]
    #[doc = ""]
    #[doc = "  @param account - the account"]
    #[doc = ""]
    #[doc = "  @return the creation time (in microseconds since Unix epoch) of the account"]
    pub fn get_account_creation_time(account: capi_name) -> i64;
}
extern "C" {
    #[doc = " Get the resource limits of an account"]
    #[doc = ""]
    #[doc = " @param account - name of the account whose resource limit to get"]
    #[doc = " @param ram_bytes - pointer to `int64_t` to hold retrieved ram limit in absolute bytes"]
    #[doc = " @param net_weight - pointer to `int64_t` to hold net limit"]
    #[doc = " @param cpu_weight - pointer to `int64_t` to hold cpu limit"]
    pub fn get_resource_limits(
        account: capi_name,
        ram_bytes: *mut i64,
        net_weight: *mut i64,
        cpu_weight: *mut i64,
    );
}
extern "C" {
    #[doc = " Set the resource limits of an account"]
    #[doc = ""]
    #[doc = " @param account - name of the account whose resource limit to be set"]
    #[doc = " @param ram_bytes - ram limit in absolute bytes"]
    #[doc = " @param net_weight - fractionally proportionate net limit of available resources based on (weight / total_weight_of_all_accounts)"]
    #[doc = " @param cpu_weight - fractionally proportionate cpu limit of available resources based on (weight / total_weight_of_all_accounts)"]
    pub fn set_resource_limits(
        account: capi_name,
        ram_bytes: i64,
        net_weight: i64,
        cpu_weight: i64,
    );
}
extern "C" {
    #[doc = " Proposes a schedule change"]
    #[doc = ""]
    #[doc = " This is exactly equivalent to calling `set_proposed_producers_ex(0, producer_data, producer_data_size)`"]
    #[doc = ""]
    #[doc = " @note Once the block that contains the proposal becomes irreversible, the schedule is promoted to \"pending\" automatically. Once the block that promotes the schedule is irreversible, the schedule will become \"active\""]
    #[doc = " @param producer_data - packed data of produce_keys in the appropriate producer schedule order"]
    #[doc = " @param producer_data_size - size of the data buffer"]
    #[doc = ""]
    #[doc = " @return -1 if proposing a new producer schedule was unsuccessful, otherwise returns the version of the new proposed schedule"]
    pub fn set_proposed_producers(
        producer_data: *mut ::std::os::raw::c_char,
        producer_data_size: u32,
    ) -> i64;
}
extern "C" {
    #[doc = " Proposes a schedule change with extended features"]
    #[doc = ""]
    #[doc = " Valid formats:"]
    #[doc = " 0 : serialized array of producer_key's. using this format is exactly equivalent to `set_proposed_producers(producer_data, producer_data_size)`"]
    #[doc = " 1 : serialized array of producer_authority's"]
    #[doc = ""]
    #[doc = " @note Once the block that contains the proposal becomes irreversible, the schedule is promoted to \"pending\" automatically. Once the block that promotes the schedule is irreversible, the schedule will become \"active\""]
    #[doc = " @param producer_data_format - format of the producer data blob"]
    #[doc = " @param producer_data - packed data of representing the producer schedule in the format indicated."]
    #[doc = " @param producer_data_size - size of the data buffer"]
    #[doc = ""]
    #[doc = " @return -1 if proposing a new producer schedule was unsuccessful, otherwise returns the version of the new proposed schedule"]
    pub fn set_proposed_producers_ex(
        producer_data_format: u64,
        producer_data: *mut ::std::os::raw::c_char,
        producer_data_size: u32,
    ) -> i64;
}
extern "C" {
    #[doc = " Check if an account is privileged"]
    #[doc = ""]
    #[doc = " @param account - name of the account to be checked"]
    #[doc = " @return true if the account is privileged"]
    #[doc = " @return false if the account is not privileged"]
    pub fn is_privileged(account: capi_name) -> bool;
}
extern "C" {
    #[doc = " Set the privileged status of an account"]
    #[doc = ""]
    #[doc = " @param account - name of the account whose privileged account to be set"]
    #[doc = " @param is_priv - privileged status"]
    pub fn set_privileged(account: capi_name, is_priv: bool);
}
extern "C" {
    #[doc = " Set the blockchain parameters"]
    #[doc = ""]
    #[doc = " @param data - pointer to blockchain parameters packed as bytes"]
    #[doc = " @param datalen - size of the packed blockchain parameters"]
    #[doc = " @pre `data` is a valid pointer to a range of memory at least `datalen` bytes long that contains packed blockchain params data"]
    pub fn set_blockchain_parameters_packed(data: *mut ::std::os::raw::c_char, datalen: u32);
}
extern "C" {
    #[doc = " Retrieve the blolckchain parameters"]
    #[doc = ""]
    #[doc = " @param data - output buffer of the blockchain parameters, only retrieved if sufficent size to hold packed data."]
    #[doc = " @param datalen - size of the data buffer, 0 to report required size."]
    #[doc = " @return size of the blockchain parameters"]
    #[doc = " @pre `data` is a valid pointer to a range of memory at least `datalen` bytes long"]
    #[doc = " @post `data` is filled with packed blockchain parameters"]
    pub fn get_blockchain_parameters_packed(data: *mut ::std::os::raw::c_char, datalen: u32)
        -> u32;
}
extern "C" {
    #[doc = " Pre-activate protocol feature"]
    #[doc = ""]
    #[doc = " @param feature_digest - digest of the protocol feature to pre-activate"]
    pub fn preactivate_feature(feature_digest: *const capi_checksum256);
}
extern "C" {
    #[doc = "  Sends a deferred transaction."]
    #[doc = ""]
    #[doc = "  @param sender_id - ID of sender"]
    #[doc = "  @param payer - Account paying for RAM"]
    #[doc = "  @param serialized_transaction - Pointer of serialized transaction to be deferred"]
    #[doc = "  @param size - Size to reserve"]
    #[doc = "  @param replace_existing - f this is `0` then if the provided sender_id is already in use by an in-flight transaction from this contract, which will be a failing assert. If `1` then transaction will atomically cancel/replace the inflight transaction"]
    pub fn send_deferred(
        sender_id: *const uint128_t,
        payer: capi_name,
        serialized_transaction: *const ::std::os::raw::c_char,
        size: usize,
        replace_existing: u32,
    );
}
extern "C" {
    #[doc = "  Cancels a deferred transaction."]
    #[doc = ""]
    #[doc = "  @brief Cancels a deferred transaction."]
    #[doc = "  @param sender_id - The id of the sender"]
    #[doc = ""]
    #[doc = "  @pre The deferred transaction ID exists."]
    #[doc = "  @pre The deferred transaction ID has not yet been published."]
    #[doc = "  @post Deferred transaction canceled."]
    #[doc = ""]
    #[doc = "  @return 1 if transaction was canceled, 0 if transaction was not found"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  id = 0xffffffffffffffff"]
    #[doc = "  cancel_deferred( id );"]
    #[doc = "  @endcode"]
    pub fn cancel_deferred(sender_id: *const uint128_t) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Access a copy of the currently executing transaction."]
    #[doc = ""]
    #[doc = " @brief Access a copy of the currently executing transaction."]
    #[doc = " @param buffer - a buffer to write the current transaction to"]
    #[doc = " @param size - the size of the buffer, 0 to return required size"]
    #[doc = " @return the size of the transaction written to the buffer, or number of bytes that can be copied if size==0 passed"]
    pub fn read_transaction(buffer: *mut ::std::os::raw::c_char, size: usize) -> usize;
}
extern "C" {
    #[doc = " Gets the size of the currently executing transaction."]
    #[doc = ""]
    #[doc = " @brief Gets the size of the currently executing transaction."]
    #[doc = " @return size of the currently executing transaction"]
    pub fn transaction_size() -> usize;
}
extern "C" {
    #[doc = " Gets the block number used for TAPOS on the currently executing transaction."]
    #[doc = ""]
    #[doc = " @brief Gets the block number used for TAPOS on the currently executing transaction."]
    #[doc = " @return block number used for TAPOS on the currently executing transaction"]
    #[doc = " Example:"]
    #[doc = " @code"]
    #[doc = " int tbn = tapos_block_num();"]
    #[doc = " @endcode"]
    pub fn tapos_block_num() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the block prefix used for TAPOS on the currently executing transaction."]
    #[doc = ""]
    #[doc = " @brief Gets the block prefix used for TAPOS on the currently executing transaction."]
    #[doc = " @return block prefix used for TAPOS on the currently executing transaction"]
    #[doc = " Example:"]
    #[doc = " @code"]
    #[doc = " int tbp = tapos_block_prefix();"]
    #[doc = " @endcode"]
    pub fn tapos_block_prefix() -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Gets the expiration of the currently executing transaction."]
    #[doc = ""]
    #[doc = " @brief Gets the expiration of the currently executing transaction."]
    #[doc = " @return expiration of the currently executing transaction in seconds since Unix epoch"]
    #[doc = " Example:"]
    #[doc = " @code"]
    #[doc = " uint32_t tm = expiration();"]
    #[doc = " eosio_print(tm);"]
    #[doc = " @endcode"]
    pub fn expiration() -> u32;
}
extern "C" {
    #[doc = " Retrieves the indicated action from the active transaction."]
    #[doc = ""]
    #[doc = " @brief Retrieves the indicated action from the active transaction."]
    #[doc = " @param type - 0 for context free action, 1 for action"]
    #[doc = " @param index - the index of the requested action"]
    #[doc = " @param buff - output packed buff of the action"]
    #[doc = " @param size - amount of buff read, pass 0 to have size returned"]
    #[doc = " @return the size of the action, -1 on failure"]
    pub fn get_action(
        type_: u32,
        index: u32,
        buff: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Retrieve the signed_transaction.context_free_data[index]."]
    #[doc = ""]
    #[doc = " @brief Retrieve the signed_transaction.context_free_data[index]."]
    #[doc = " @param index - the index of the context_free_data entry to retrieve"]
    #[doc = " @param buff - output buff of the context_free_data entry"]
    #[doc = " @param size - amount of context_free_data[index] to retrieve into buff, 0 to report required size"]
    #[doc = " @return size copied, or context_free_data[index].size() if 0 passed for size, or -1 if index not valid"]
    pub fn get_context_free_data(
        index: u32,
        buff: *mut ::std::os::raw::c_char,
        size: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = "  Gets the set of active producers."]
    #[doc = ""]
    #[doc = "  @param producers - Pointer to a buffer of account names"]
    #[doc = "  @param datalen - Byte length of buffer, when passed 0 will return the size required to store full output."]
    #[doc = ""]
    #[doc = "  @return uint32_t - Number of bytes actually populated"]
    #[doc = "  @pre `producers` is a pointer to a range of memory at least `datalen` bytes long"]
    #[doc = "  @post the passed in `producers` pointer gets the array of active producers."]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  capi_name producers[21];"]
    #[doc = "  uint32_t bytes_populated = get_active_producers(producers, sizeof(capi_name)*21);"]
    #[doc = "  @endcode"]
    pub fn get_active_producers(producers: *mut capi_name, datalen: u32) -> u32;
}
extern "C" {
    #[doc = "  Store a record in a primary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Store a record in a primary 64-bit integer index table"]
    #[doc = "  @param scope - The scope where the table resides (implied to be within the code of the current receiver)"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param payer - The account that pays for the storage costs"]
    #[doc = "  @param id - ID of the entry"]
    #[doc = "  @param data - Record to store"]
    #[doc = "  @param len - Size of data"]
    #[doc = "  @pre `data` is a valid pointer to a range of memory at least `len` bytes long"]
    #[doc = "  @pre `*((uint64_t*)data)` stores the primary key"]
    #[doc = "  @return iterator to the newly created table row"]
    #[doc = "  @post a new entry is created in the table"]
    pub fn db_store_i64(
        scope: u64,
        table: capi_name,
        payer: capi_name,
        id: u64,
        data: *const ::std::os::raw::c_void,
        len: u32,
    ) -> i32;
}
extern "C" {
    #[doc = "  Update a record in a primary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Update a record in a primary 64-bit integer index table"]
    #[doc = "  @param iterator - Iterator to the table row containing the record to update"]
    #[doc = "  @param payer - The account that pays for the storage costs (use 0 to continue using current payer)"]
    #[doc = "  @param data - New updated record"]
    #[doc = "  @param len - Size of data"]
    #[doc = "  @pre `data` is a valid pointer to a range of memory at least `len` bytes long"]
    #[doc = "  @pre `*((uint64_t*)data)` stores the primary key"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the record contained in the table row pointed to by `iterator` is replaced with the new updated record"]
    pub fn db_update_i64(
        iterator: i32,
        payer: capi_name,
        data: *const ::std::os::raw::c_void,
        len: u32,
    );
}
extern "C" {
    #[doc = "  Remove a record from a primary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Remove a record from a primary 64-bit integer index table"]
    #[doc = "  @param iterator - Iterator to the table row to remove"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  int32_t itr = db_find_i64(receiver, receiver, table1, \"alice\"_n);"]
    #[doc = "  eosio_assert(itr >= 0, \"Alice cannot be removed since she was already not found in the table\");"]
    #[doc = "  db_remove_i64(itr);"]
    #[doc = "  @endcode"]
    pub fn db_remove_i64(iterator: i32);
}
extern "C" {
    #[doc = "  Get a record in a primary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Get a record in a primary 64-bit integer index table"]
    #[doc = "  @param iterator - The iterator to the table row containing the record to retrieve"]
    #[doc = "  @param data - Pointer to the buffer which will be filled with the retrieved record"]
    #[doc = "  @param len - Size of the buffer"]
    #[doc = "  @return size of the data copied into the buffer if `len > 0`, or size of the retrieved record if `len == 0`."]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @pre `data` is a valid pointer to a range of memory at least `len` bytes long"]
    #[doc = "  @post `data` will be filled with the retrieved record (truncated to the first `len` bytes if necessary)"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  char value[50];"]
    #[doc = "  auto len = db_get_i64(itr, value, 0);"]
    #[doc = "  eosio_assert(len <= 50, \"buffer to small to store retrieved record\");"]
    #[doc = "  db_get_i64(itr, value, len);"]
    #[doc = "  @endcode"]
    pub fn db_get_i64(iterator: i32, data: *const ::std::os::raw::c_void, len: u32) -> i32;
}
extern "C" {
    #[doc = "  Find the table row following the referenced table row in a primary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row following the referenced table row in a primary 64-bit integer index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row"]
    #[doc = "  @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  int32_t charlie_itr = db_find_i64(receiver, receiver, table1, \"charlie\"_n);"]
    #[doc = "  // expect nothing after charlie"]
    #[doc = "  uint64_t prim = 0"]
    #[doc = "  int32_t  end_itr = db_next_i64(charlie_itr, &prim);"]
    #[doc = "  eosio_assert(end_itr < -1, \"Charlie was not the last entry in the table\");"]
    #[doc = "  @endcode"]
    pub fn db_next_i64(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find the table row preceding the referenced table row in a primary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row preceding the referenced table row in a primary 64-bit integer index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row"]
    #[doc = "  @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table or it is the end iterator of the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  uint64_t prim = 0;"]
    #[doc = "  int32_t  itr_prev = db_previous_i64(itr, &prim);"]
    #[doc = "  @endcode"]
    pub fn db_previous_i64(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find a table row in a primary 64-bit integer index table by primary key"]
    #[doc = ""]
    #[doc = "  @brief Find a table row in a primary 64-bit integer index table by primary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param id - The primary key of the table row to look up"]
    #[doc = "  @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  int itr = db_find_i64(receiver, receiver, table1, \"charlie\"_n);"]
    #[doc = "  @endcode"]
    pub fn db_find_i64(code: capi_name, scope: u64, table: capi_name, id: u64) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a primary 64-bit integer index table that matches the lowerbound condition for a given primary key"]
    #[doc = "  The table row that matches the lowerbound condition is the first table row in the table with the lowest primary key that is >= the given key"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a primary 64-bit integer index table that matches the lowerbound condition for a given primary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param id - The primary key used to determine the lowerbound"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_lowerbound_i64(code: capi_name, scope: u64, table: capi_name, id: u64) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a primary 64-bit integer index table that matches the upperbound condition for a given primary key"]
    #[doc = "  The table row that matches the upperbound condition is the first table row in the table with the lowest primary key that is > the given key"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a primary 64-bit integer index table that matches the upperbound condition for a given primary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param id - The primary key used to determine the upperbound"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_upperbound_i64(code: capi_name, scope: u64, table: capi_name, id: u64) -> i32;
}
extern "C" {
    #[doc = "  Get an iterator representing just-past-the-end of the last table row of a primary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Get an iterator representing just-past-the-end of the last table row of a primary 64-bit integer index table"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @return end iterator of the table"]
    pub fn db_end_i64(code: capi_name, scope: u64, table: capi_name) -> i32;
}
extern "C" {
    #[doc = "  Store an association of a 64-bit integer secondary key to a primary key in a secondary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Store an association of a 64-bit integer secondary key to a primary key in a secondary 64-bit integer index table"]
    #[doc = "  @param scope - The scope where the table resides (implied to be within the code of the current receiver)"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param payer - The account that pays for the storage costs"]
    #[doc = "  @param id - The primary key to which to associate the secondary key"]
    #[doc = "  @param secondary - Pointer to the secondary key"]
    #[doc = "  @return iterator to the newly created table row"]
    #[doc = "  @post new secondary key association between primary key `id` and secondary key `*secondary` is created in the secondary 64-bit integer index table"]
    pub fn db_idx64_store(
        scope: u64,
        table: capi_name,
        payer: capi_name,
        id: u64,
        secondary: *const u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Update an association for a 64-bit integer secondary key to a primary key in a secondary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Update an association for a 64-bit integer secondary key to a primary key in a secondary 64-bit integer index table"]
    #[doc = "  @param iterator - The iterator to the table row containing the secondary key association to update"]
    #[doc = "  @param payer - The account that pays for the storage costs (use 0 to continue using current payer)"]
    #[doc = "  @param secondary - Pointer to the **new** secondary key that will replace the existing one of the association"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the secondary key of the table row pointed to by `iterator` is replaced by `*secondary`"]
    pub fn db_idx64_update(iterator: i32, payer: capi_name, secondary: *const u64);
}
extern "C" {
    #[doc = "  Remove a table row from a secondary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Remove a table row from a secondary 64-bit integer index table"]
    #[doc = "  @param iterator - Iterator to the table row to remove"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer"]
    pub fn db_idx64_remove(iterator: i32);
}
extern "C" {
    #[doc = "  Find the table row following the referenced table row in a secondary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row following the referenced table row in a secondary 64-bit integer index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row"]
    #[doc = "  @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    pub fn db_idx64_next(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find the table row preceding the referenced table row in a secondary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row preceding the referenced table row in a secondary 64-bit integer index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row"]
    #[doc = "  @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table or it is the end iterator of the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    pub fn db_idx64_previous(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find a table row in a secondary 64-bit integer index table by primary key"]
    #[doc = ""]
    #[doc = "  @brief Find a table row in a secondary 64-bit integer index table by primary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to a `uint64_t` variable which will have its value set to the secondary key of the found table row"]
    #[doc = "  @param primary - The primary key of the table row to look up"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found"]
    pub fn db_idx64_find_primary(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut u64,
        primary: u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find a table row in a secondary 64-bit integer index table by secondary key"]
    #[doc = ""]
    #[doc = "  @brief Find a table row in a secondary 64-bit integer index table by secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key used to lookup the table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the first table row with a secondary key equal to `*secondary` or the end iterator of the table if the table row could not be found"]
    pub fn db_idx64_find_secondary(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *const u64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a secondary 64-bit integer index table that matches the lowerbound condition for a given secondary key"]
    #[doc = "  The table row that matches the lowerbound condition is the first table row in the table with the lowest secondary key that is >= the given key"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a secondary 64-bit integer index table that matches the lowerbound condition for a given secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key first used to determine the lowerbound and which is then replaced with the secondary key of the found table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_idx64_lowerbound(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut u64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a secondary 64-bit integer index table that matches the upperbound condition for a given secondary key"]
    #[doc = "  The table row that matches the upperbound condition is the first table row in the table with the lowest secondary key that is > the given key"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a secondary 64-bit integer index table that matches the upperbound condition for a given secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key first used to determine the upperbound and which is then replaced with the secondary key of the found table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_idx64_upperbound(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut u64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Get an end iterator representing just-past-the-end of the last table row of a secondary 64-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Get an end iterator representing just-past-the-end of the last table row of a secondary 64-bit integer index table"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @return end iterator of the table"]
    pub fn db_idx64_end(code: capi_name, scope: u64, table: capi_name) -> i32;
}
extern "C" {
    #[doc = "  Store an association of a 128-bit integer secondary key to a primary key in a secondary 128-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Store an association of a 128-bit integer secondary key to a primary key in a secondary 128-bit integer index table"]
    #[doc = "  @param scope - The scope where the table resides (implied to be within the code of the current receiver)"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param payer - The account that pays for the storage costs"]
    #[doc = "  @param id - The primary key to which to associate the secondary key"]
    #[doc = "  @param secondary - Pointer to the secondary key"]
    #[doc = "  @return iterator to the newly created table row"]
    #[doc = "  @post new secondary key association between primary key `id` and secondary key `*secondary` is created in the secondary 128-bit integer index table"]
    pub fn db_idx128_store(
        scope: u64,
        table: capi_name,
        payer: capi_name,
        id: u64,
        secondary: *const uint128_t,
    ) -> i32;
}
extern "C" {
    #[doc = "  Update an association for a 128-bit integer secondary key to a primary key in a secondary 128-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Update an association for a 128-bit integer secondary key to a primary key in a secondary 128-bit integer index table"]
    #[doc = "  @param iterator - The iterator to the table row containing the secondary key association to update"]
    #[doc = "  @param payer - The account that pays for the storage costs (use 0 to continue using current payer)"]
    #[doc = "  @param secondary - Pointer to the **new** secondary key that will replace the existing one of the association"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the secondary key of the table row pointed to by `iterator` is replaced by `*secondary`"]
    pub fn db_idx128_update(iterator: i32, payer: capi_name, secondary: *const uint128_t);
}
extern "C" {
    #[doc = "  Remove a table row from a secondary 128-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Remove a table row from a secondary 128-bit integer index table"]
    #[doc = "  @param iterator - Iterator to the table row to remove"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer"]
    pub fn db_idx128_remove(iterator: i32);
}
extern "C" {
    #[doc = "  Find the table row following the referenced table row in a secondary 128-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row following the referenced table row in a secondary 128-bit integer index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row"]
    #[doc = "  @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    pub fn db_idx128_next(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find the table row preceding the referenced table row in a secondary 128-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row preceding the referenced table row in a secondary 128-bit integer index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row"]
    #[doc = "  @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table or it is the end iterator of the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    pub fn db_idx128_previous(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find a table row in a secondary 128-bit integer index table by primary key"]
    #[doc = ""]
    #[doc = "  @brief Find a table row in a secondary 128-bit integer index table by primary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to a `uint128_t` variable which will have its value set to the secondary key of the found table row"]
    #[doc = "  @param primary - The primary key of the table row to look up"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found"]
    pub fn db_idx128_find_primary(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut uint128_t,
        primary: u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find a table row in a secondary 128-bit integer index table by secondary key"]
    #[doc = ""]
    #[doc = "  @brief Find a table row in a secondary 128-bit integer index table by secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key used to lookup the table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the first table row with a secondary key equal to `*secondary` or the end iterator of the table if the table row could not be found"]
    pub fn db_idx128_find_secondary(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *const uint128_t,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a secondary 128-bit integer index table that matches the lowerbound condition for a given secondary key"]
    #[doc = "  The table row that matches the lowerbound condition is the first table row in the table with the lowest secondary key that is >= the given key"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a secondary 128-bit integer index table that matches the lowerbound condition for a given secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key first used to determine the lowerbound and which is then replaced with the secondary key of the found table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_idx128_lowerbound(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut uint128_t,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a secondary 128-bit integer index table that matches the upperbound condition for a given secondary key"]
    #[doc = "  The table row that matches the upperbound condition is the first table row in the table with the lowest secondary key that is > the given key"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a secondary 128-bit integer index table that matches the upperbound condition for a given secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key first used to determine the upperbound and which is then replaced with the secondary key of the found table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_idx128_upperbound(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut uint128_t,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Get an end iterator representing just-past-the-end of the last table row of a secondary 128-bit integer index table"]
    #[doc = ""]
    #[doc = "  @brief Get an end iterator representing just-past-the-end of the last table row of a secondary 128-bit integer index table"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @return end iterator of the table"]
    pub fn db_idx128_end(code: capi_name, scope: u64, table: capi_name) -> i32;
}
extern "C" {
    #[doc = "  Store an association of a 256-bit secondary key to a primary key in a secondary 256-bit index table"]
    #[doc = ""]
    #[doc = "  @brief Store an association of a 256-bit secondary key to a primary key in a secondary 256-bit index table"]
    #[doc = "  @param scope - The scope where the table resides (implied to be within the code of the current receiver)"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param payer - The account that pays for the storage costs"]
    #[doc = "  @param id - The primary key to which to associate the secondary key"]
    #[doc = "  @param data - Pointer to the secondary key data stored as an array of 2 `uint128_t` integers"]
    #[doc = "  @param data_len - Must be set to 2"]
    #[doc = "  @return iterator to the newly created table row"]
    #[doc = "  @post new secondary key association between primary key `id` and the specified secondary key is created in the secondary 256-bit index table"]
    pub fn db_idx256_store(
        scope: u64,
        table: capi_name,
        payer: capi_name,
        id: u64,
        data: *const uint128_t,
        data_len: u32,
    ) -> i32;
}
extern "C" {
    #[doc = "  Update an association for a 256-bit secondary key to a primary key in a secondary 256-bit index table"]
    #[doc = ""]
    #[doc = "  @brief Update an association for a 256-bit secondary key to a primary key in a secondary 256-bit index table"]
    #[doc = "  @param iterator - The iterator to the table row containing the secondary key association to update"]
    #[doc = "  @param payer - The account that pays for the storage costs (use 0 to continue using current payer)"]
    #[doc = "  @param data - Pointer to the **new** secondary key data (which is stored as an array of 2 `uint128_t` integers) that will replace the existing one of the association"]
    #[doc = "  @param data_len - Must be set to 2"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the secondary key of the table row pointed to by `iterator` is replaced by the specified secondary key"]
    pub fn db_idx256_update(iterator: i32, payer: capi_name, data: *const uint128_t, data_len: u32);
}
extern "C" {
    #[doc = "  Remove a table row from a secondary 256-bit index table"]
    #[doc = ""]
    #[doc = "  @brief Remove a table row from a secondary 256-bit index table"]
    #[doc = "  @param iterator - Iterator to the table row to remove"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer"]
    pub fn db_idx256_remove(iterator: i32);
}
extern "C" {
    #[doc = "  Find the table row following the referenced table row in a secondary 256-bit index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row following the referenced table row in a secondary 256-bit index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row"]
    #[doc = "  @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    pub fn db_idx256_next(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find the table row preceding the referenced table row in a secondary 256-bit index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row preceding the referenced table row in a secondary 256-bit index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row"]
    #[doc = "  @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table or it is the end iterator of the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    pub fn db_idx256_previous(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find a table row in a secondary 256-bit index table by primary key"]
    #[doc = ""]
    #[doc = "  @brief Find a table row in a secondary 128-bit integer index table by primary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param data - Pointer to the an array of 2 `uint128_t` integers which will act as the buffer to hold the retrieved secondary key of the found table row"]
    #[doc = "  @param data_len - Must be set to 2"]
    #[doc = "  @param primary - The primary key of the table row to look up"]
    #[doc = "  @post If and only if the table row is found, the buffer pointed to by `data` will be filled with the secondary key of the found table row"]
    #[doc = "  @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found"]
    pub fn db_idx256_find_primary(
        code: capi_name,
        scope: u64,
        table: capi_name,
        data: *mut uint128_t,
        data_len: u32,
        primary: u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find a table row in a secondary 256-bit index table by secondary key"]
    #[doc = ""]
    #[doc = "  @brief Find a table row in a secondary 256-bit index table by secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param data - Pointer to the secondary key data (which is stored as an array of 2 `uint128_t` integers) used to lookup the table row"]
    #[doc = "  @param data_len - Must be set to 2"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the first table row with a secondary key equal to the specified secondary key or the end iterator of the table if the table row could not be found"]
    pub fn db_idx256_find_secondary(
        code: capi_name,
        scope: u64,
        table: capi_name,
        data: *const uint128_t,
        data_len: u32,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a secondary 256-bit index table that matches the lowerbound condition for a given secondary key"]
    #[doc = "  The table row that matches the lowerbound condition is the first table row in the table with the lowest secondary key that is >= the given key (uses lexicographical ordering on the 256-bit keys)"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a secondary 256-bit index table that matches the lowerbound condition for a given secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param data - Pointer to the secondary key data (which is stored as an array of 2 `uint128_t` integers) first used to determine the lowerbound and which is then replaced with the secondary key of the found table row"]
    #[doc = "  @param data_len - Must be set to 2"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, the buffer pointed to by `data` will be filled with the secondary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_idx256_lowerbound(
        code: capi_name,
        scope: u64,
        table: capi_name,
        data: *mut uint128_t,
        data_len: u32,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a secondary 256-bit index table that matches the upperbound condition for a given secondary key"]
    #[doc = "  The table row that matches the upperbound condition is the first table row in the table with the lowest secondary key that is > the given key (uses lexicographical ordering on the 256-bit keys)"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a secondary 256-bit index table that matches the upperbound condition for a given secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param data - Pointer to the secondary key data (which is stored as an array of 2 `uint128_t` integers) first used to determine the upperbound and which is then replaced with the secondary key of the found table row"]
    #[doc = "  @param data_len - Must be set to 2"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, the buffer pointed to by `data` will be filled with the secondary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_idx256_upperbound(
        code: capi_name,
        scope: u64,
        table: capi_name,
        data: *mut uint128_t,
        data_len: u32,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Get an end iterator representing just-past-the-end of the last table row of a secondary 256-bit index table"]
    #[doc = ""]
    #[doc = "  @brief Get an end iterator representing just-past-the-end of the last table row of a secondary 256-bit index table"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @return end iterator of the table"]
    pub fn db_idx256_end(code: capi_name, scope: u64, table: capi_name) -> i32;
}
extern "C" {
    #[doc = "  Store an association of a double-precision floating-point secondary key to a primary key in a secondary double-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Store an association of a double-precision floating-point secondary key to a primary key in a secondary double-precision floating-point index table"]
    #[doc = "  @param scope - The scope where the table resides (implied to be within the code of the current receiver)"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param payer - The account that pays for the storage costs"]
    #[doc = "  @param id - The primary key to which to associate the secondary key"]
    #[doc = "  @param secondary - Pointer to the secondary key"]
    #[doc = "  @return iterator to the newly created table row"]
    #[doc = "  @post new secondary key association between primary key `id` and secondary key `*secondary` is created in the secondary double-precision floating-point index table"]
    pub fn db_idx_double_store(
        scope: u64,
        table: capi_name,
        payer: capi_name,
        id: u64,
        secondary: *const f64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Update an association for a double-precision floating-point secondary key to a primary key in a secondary double-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Update an association for a double-precision floating-point secondary key to a primary key in a secondary double-precision floating-point index table"]
    #[doc = "  @param iterator - The iterator to the table row containing the secondary key association to update"]
    #[doc = "  @param payer - The account that pays for the storage costs (use 0 to continue using current payer)"]
    #[doc = "  @param secondary - Pointer to the **new** secondary key that will replace the existing one of the association"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the secondary key of the table row pointed to by `iterator` is replaced by `*secondary`"]
    pub fn db_idx_double_update(iterator: i32, payer: capi_name, secondary: *const f64);
}
extern "C" {
    #[doc = "  Remove a table row from a secondary double-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Remove a table row from a secondary double-precision floating-point index table"]
    #[doc = "  @param iterator - Iterator to the table row to remove"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer"]
    pub fn db_idx_double_remove(iterator: i32);
}
extern "C" {
    #[doc = "  Find the table row following the referenced table row in a secondary double-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row following the referenced table row in a secondary double-precision floating-point index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row"]
    #[doc = "  @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    pub fn db_idx_double_next(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find the table row preceding the referenced table row in a secondary double-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row preceding the referenced table row in a secondary double-precision floating-point index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row"]
    #[doc = "  @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table or it is the end iterator of the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    pub fn db_idx_double_previous(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find a table row in a secondary double-precision floating-point index table by primary key"]
    #[doc = ""]
    #[doc = "  @brief Find a table row in a secondary double-precision floating-point index table by primary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to a `double` variable which will have its value set to the secondary key of the found table row"]
    #[doc = "  @param primary - The primary key of the table row to look up"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found"]
    pub fn db_idx_double_find_primary(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut f64,
        primary: u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find a table row in a secondary double-precision floating-point index table by secondary key"]
    #[doc = ""]
    #[doc = "  @brief Find a table row in a secondary double-precision floating-point index table by secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key used to lookup the table row"]
    #[doc = "  @param primary - Pointer to a `double` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the first table row with a secondary key equal to `*secondary` or the end iterator of the table if the table row could not be found"]
    pub fn db_idx_double_find_secondary(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *const f64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a secondary double-precision floating-point index table that matches the lowerbound condition for a given secondary key"]
    #[doc = "  The table row that matches the lowerbound condition is the first table row in the table with the lowest secondary key that is >= the given key"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a secondary double-precision floating-point index table that matches the lowerbound condition for a given secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key first used to determine the lowerbound and which is then replaced with the secondary key of the found table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_idx_double_lowerbound(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut f64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a secondary double-precision floating-point index table that matches the upperbound condition for a given secondary key"]
    #[doc = "  The table row that matches the upperbound condition is the first table row in the table with the lowest secondary key that is > the given key"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a secondary double-precision floating-point index table that matches the upperbound condition for a given secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key first used to determine the upperbound and which is then replaced with the secondary key of the found table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_idx_double_upperbound(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut f64,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Get an end iterator representing just-past-the-end of the last table row of a secondary double-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Get an end iterator representing just-past-the-end of the last table row of a secondary double-precision floating-point index table"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @return end iterator of the table"]
    pub fn db_idx_double_end(code: capi_name, scope: u64, table: capi_name) -> i32;
}
extern "C" {
    #[doc = "  Store an association of a quadruple-precision floating-point secondary key to a primary key in a secondary quadruple-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Store an association of a quadruple-precision floating-point secondary key to a primary key in a secondary quadruple-precision floating-point index table"]
    #[doc = "  @param scope - The scope where the table resides (implied to be within the code of the current receiver)"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param payer - The account that pays for the storage costs"]
    #[doc = "  @param id - The primary key to which to associate the secondary key"]
    #[doc = "  @param secondary - Pointer to the secondary key"]
    #[doc = "  @return iterator to the newly created table row"]
    #[doc = "  @post new secondary key association between primary key `id` and secondary key `*secondary` is created in the secondary quadruple-precision floating-point index table"]
    pub fn db_idx_long_double_store(
        scope: u64,
        table: capi_name,
        payer: capi_name,
        id: u64,
        secondary: *const u128,
    ) -> i32;
}
extern "C" {
    #[doc = "  Update an association for a quadruple-precision floating-point secondary key to a primary key in a secondary quadruple-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Update an association for a quadruple-precision floating-point secondary key to a primary key in a secondary quadruple-precision floating-point index table"]
    #[doc = "  @param iterator - The iterator to the table row containing the secondary key association to update"]
    #[doc = "  @param payer - The account that pays for the storage costs (use 0 to continue using current payer)"]
    #[doc = "  @param secondary - Pointer to the **new** secondary key that will replace the existing one of the association"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the secondary key of the table row pointed to by `iterator` is replaced by `*secondary`"]
    pub fn db_idx_long_double_update(iterator: i32, payer: capi_name, secondary: *const u128);
}
extern "C" {
    #[doc = "  Remove a table row from a secondary quadruple-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Remove a table row from a secondary quadruple-precision floating-point index table"]
    #[doc = "  @param iterator - Iterator to the table row to remove"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post the table row pointed to by `iterator` is removed and the associated storage costs are refunded to the payer"]
    pub fn db_idx_long_double_remove(iterator: i32);
}
extern "C" {
    #[doc = "  Find the table row following the referenced table row in a secondary quadruple-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row following the referenced table row in a secondary quadruple-precision floating-point index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the next table row"]
    #[doc = "  @return iterator to the table row following the referenced table row (or the end iterator of the table if the referenced table row is the last one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row following the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    pub fn db_idx_long_double_next(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find the table row preceding the referenced table row in a secondary quadruple-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Find the table row preceding the referenced table row in a secondary quadruple-precision floating-point index table"]
    #[doc = "  @param iterator - The iterator to the referenced table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the previous table row"]
    #[doc = "  @return iterator to the table row preceding the referenced table row assuming one exists (it will return -1 if the referenced table row is the first one in the table)"]
    #[doc = "  @pre `iterator` points to an existing table row in the table or it is the end iterator of the table"]
    #[doc = "  @post `*primary` will be replaced with the primary key of the table row preceding the referenced table row if it exists, otherwise `*primary` will be left untouched"]
    pub fn db_idx_long_double_previous(iterator: i32, primary: *mut u64) -> i32;
}
extern "C" {
    #[doc = "  Find a table row in a secondary quadruple-precision floating-point index table by primary key"]
    #[doc = ""]
    #[doc = "  @brief Find a table row in a secondary quadruple-precision floating-point index table by primary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to a `long double` variable which will have its value set to the secondary key of the found table row"]
    #[doc = "  @param primary - The primary key of the table row to look up"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @return iterator to the table row with a primary key equal to `id` or the end iterator of the table if the table row could not be found"]
    pub fn db_idx_long_double_find_primary(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut u128,
        primary: u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find a table row in a secondary quadruple-precision floating-point index table by secondary key"]
    #[doc = ""]
    #[doc = "  @brief Find a table row in a secondary quadruple-precision floating-point index table by secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key used to lookup the table row"]
    #[doc = "  @param primary - Pointer to a `long double` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the first table row with a secondary key equal to `*secondary` or the end iterator of the table if the table row could not be found"]
    pub fn db_idx_long_double_find_secondary(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *const u128,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a secondary quadruple-precision floating-point index table that matches the lowerbound condition for a given secondary key"]
    #[doc = "  The table row that matches the lowerbound condition is the first table row in the table with the lowest secondary key that is >= the given key"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a secondary quadruple-precision floating-point index table that matches the lowerbound condition for a given secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key first used to determine the lowerbound and which is then replaced with the secondary key of the found table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_idx_long_double_lowerbound(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut u128,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Find the table row in a secondary quadruple-precision floating-point index table that matches the upperbound condition for a given secondary key"]
    #[doc = "  The table row that matches the upperbound condition is the first table row in the table with the lowest secondary key that is > the given key"]
    #[doc = ""]
    #[doc = "  @brief Find the table row in a secondary quadruple-precision floating-point index table that matches the upperbound condition for a given secondary key"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @param secondary - Pointer to secondary key first used to determine the upperbound and which is then replaced with the secondary key of the found table row"]
    #[doc = "  @param primary - Pointer to a `uint64_t` variable which will have its value set to the primary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*secondary` will be replaced with the secondary key of the found table row"]
    #[doc = "  @post If and only if the table row is found, `*primary` will be replaced with the primary key of the found table row"]
    #[doc = "  @return iterator to the found table row or the end iterator of the table if the table row could not be found"]
    pub fn db_idx_long_double_upperbound(
        code: capi_name,
        scope: u64,
        table: capi_name,
        secondary: *mut u128,
        primary: *mut u64,
    ) -> i32;
}
extern "C" {
    #[doc = "  Get an end iterator representing just-past-the-end of the last table row of a secondary quadruple-precision floating-point index table"]
    #[doc = ""]
    #[doc = "  @brief Get an end iterator representing just-past-the-end of the last table row of a secondary quadruple-precision floating-point index table"]
    #[doc = "  @param code - The name of the owner of the table"]
    #[doc = "  @param scope - The scope where the table resides"]
    #[doc = "  @param table - The table name"]
    #[doc = "  @return end iterator of the table"]
    pub fn db_idx_long_double_end(code: capi_name, scope: u64, table: capi_name) -> i32;
}
extern "C" {
    #[doc = "  Prints string"]
    #[doc = ""]
    #[doc = "  @param cstr - a null terminated string"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  prints(\"Hello World!\"); // Output: Hello World!"]
    #[doc = "  @endcode"]
    pub fn prints(cstr: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "  Prints string up to given length"]
    #[doc = ""]
    #[doc = "  @param cstr - pointer to string"]
    #[doc = "  @param len - len of string to be printed"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  prints_l(\"Hello World!\", 5); // Output: Hello"]
    #[doc = "  @endcode"]
    pub fn prints_l(cstr: *const ::std::os::raw::c_char, len: u32);
}
extern "C" {
    #[doc = " Prints value as a 64 bit signed integer"]
    #[doc = ""]
    #[doc = " @brief Prints value as a 64 bit signed integer"]
    #[doc = " @param value of 64 bit signed integer to be printed"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  printi(-1e+18); // Output: -1000000000000000000"]
    #[doc = "  @endcode"]
    pub fn printi(value: i64);
}
extern "C" {
    #[doc = " Prints value as a 64 bit unsigned integer"]
    #[doc = ""]
    #[doc = " @param value of 64 bit unsigned integer to be printed"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  printui(1e+18); // Output: 1000000000000000000"]
    #[doc = "  @endcode"]
    pub fn printui(value: u64);
}
extern "C" {
    #[doc = " Prints value as a 128 bit signed integer"]
    #[doc = ""]
    #[doc = " @param value is a pointer to the 128 bit signed integer to be printed"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  int128_t large_int(-87654323456);"]
    #[doc = "  printi128(&large_int); // Output: -87654323456"]
    #[doc = "  @endcode"]
    pub fn printi128(value: *const int128_t);
}
extern "C" {
    #[doc = " Prints value as a 128 bit unsigned integer"]
    #[doc = ""]
    #[doc = " @param value is a pointer to the 128 bit unsigned integer to be printed"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  uint128_t large_int(87654323456);"]
    #[doc = "  printui128(&large_int); // Output: 87654323456"]
    #[doc = "  @endcode"]
    pub fn printui128(value: *const uint128_t);
}
extern "C" {
    #[doc = " Prints value as single-precision floating point number"]
    #[doc = ""]
    #[doc = " @param value of float to be printed"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  float value = 5.0 / 10.0;"]
    #[doc = "  printsf(value); // Output: 0.5"]
    #[doc = "  @endcode"]
    pub fn printsf(value: f32);
}
extern "C" {
    #[doc = " Prints value as double-precision floating point number"]
    #[doc = ""]
    #[doc = " @param value of double to be printed"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  double value = 5.0 / 10.0;"]
    #[doc = "  printdf(value); // Output: 0.5"]
    #[doc = "  @endcode"]
    pub fn printdf(value: f64);
}
extern "C" {
    #[doc = " Prints value as quadruple-precision floating point number"]
    #[doc = ""]
    #[doc = " @param value is a pointer to the long double to be printed"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  long double value = 5.0 / 10.0;"]
    #[doc = "  printqf(value); // Output: 0.5"]
    #[doc = "  @endcode"]
    pub fn printqf(value: *const u128);
}
extern "C" {
    #[doc = " Prints a 64 bit names as base32 encoded string"]
    #[doc = ""]
    #[doc = " @param name - 64 bit name to be printed"]
    #[doc = ""]
    #[doc = " Example:"]
    #[doc = " @code"]
    #[doc = " printn(\"abcde\"_n); // Output: abcde"]
    #[doc = " @endcode"]
    pub fn printn(name: u64);
}
extern "C" {
    #[doc = " Prints hexidecimal data of length datalen"]
    #[doc = ""]
    #[doc = " @brief Prints hexidecimal data of length datalen"]
    #[doc = " @param data to be printed"]
    #[doc = " @param datalen length of the data to be printed"]
    #[doc = ""]
    #[doc = " Example"]
    #[doc = " @code"]
    #[doc = " unsigned char rawData[9] = {0x49 0x20 0x6C 0x6F 0x76 0x65 0x20 0x62 0x6D};"]
    #[doc = " printhex(&rawData, 9);"]
    #[doc = " @endcode"]
    pub fn printhex(data: *const ::std::os::raw::c_void, datalen: u32);
}
extern "C" {
    #[doc = "  Aborts processing of this action and unwinds all pending changes if the test condition is true"]
    #[doc = ""]
    #[doc = "  @param test - 0 to abort, 1 to ignore"]
    #[doc = ""]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  eosio_assert(1 == 2, \"One is not equal to two.\");"]
    #[doc = "  eosio_assert(1 == 1, \"One is not equal to one.\");"]
    #[doc = "  @endcode"]
    #[doc = ""]
    #[doc = "  @param msg - a null terminated string explaining the reason for failure"]
    pub fn eosio_assert(test: u32, msg: *const ::std::os::raw::c_char);
}
extern "C" {
    #[doc = "  Aborts processing of this action and unwinds all pending changes if the test condition is true"]
    #[doc = ""]
    #[doc = "  @param test - 0 to abort, 1 to ignore"]
    #[doc = "  @param msg - a pointer to the start of string explaining the reason for failure"]
    #[doc = "  @param msg_len - length of the string"]
    pub fn eosio_assert_message(test: u32, msg: *const ::std::os::raw::c_char, msg_len: u32);
}
extern "C" {
    #[doc = "  Aborts processing of this action and unwinds all pending changes if the test condition is true"]
    #[doc = ""]
    #[doc = "  @brief Aborts processing of this action and unwinds all pending changes"]
    #[doc = "  @param test - 0 to abort, 1 to ignore"]
    #[doc = "  @param code - the error code"]
    pub fn eosio_assert_code(test: u32, code: u64);
}
extern "C" {
    #[doc = "  This method will abort execution of wasm without failing the contract. This is used to bypass all cleanup / destructors that would normally be called."]
    #[doc = ""]
    #[doc = "  @param code - the exit code"]
    #[doc = "  Example:"]
    #[doc = ""]
    #[doc = "  @code"]
    #[doc = "  eosio_exit(0);"]
    #[doc = "  eosio_exit(1);"]
    #[doc = "  eosio_exit(2);"]
    #[doc = "  eosio_exit(3);"]
    #[doc = "  @endcode"]
    pub fn eosio_exit(code: i32);
}
extern "C" {
    #[doc = "  Returns the time in microseconds from 1970 of the current block"]
    #[doc = ""]
    #[doc = "  @return time in microseconds from 1970 of the current block"]
    pub fn current_time() -> u64;
}
extern "C" {
    #[doc = " Check if specified protocol feature has been activated"]
    #[doc = ""]
    #[doc = " @param feature_digest - digest of the protocol feature"]
    #[doc = " @return true if the specified protocol feature has been activated, false otherwise"]
    pub fn is_feature_activated(feature_digest: *const capi_checksum256) -> bool;
}
extern "C" {
    #[doc = " Return name of account that sent current inline action"]
    #[doc = ""]
    #[doc = " @return name of account that sent the current inline action (empty name if not called from inline action)"]
    pub fn get_sender() -> capi_name;
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
